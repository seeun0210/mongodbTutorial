# LookUp()

`$lookup`는 MongoDB에서 사용되는 강력한 어그리게이션 파이프라인 단계로, 서로 다른 컬렉션에서 데이터를 조인하거나 병합할 수 있게 해줍니다. SQL의 조인과 유사한 역할을 하지만, MongoDB는 스키마가 없기 때문에 유연하게 사용할 수 있습니다.

`$lookup`는 다음과 같은 주요 파라미터를 포함합니다:

- **`from`**: 조인할 컬렉션의 이름.
- **`localField`**: 현재 컬렉션에서 조인을 위해 사용할 필드.
- **`foreignField`**: 조인할 컬렉션에서 일치하는 필드.
- **`as`**: 결과를 저장할 필드 이름.

기본적인 `$lookup` 예시:

```json
db.orders.aggregate([
  {
    $lookup: {
      from: "customers",
      localField: "customer_id",
      foreignField: "customer_id",
      as: "customer_info"
    }
  }
])
```

이 예시에서는 `orders` 컬렉션에서 `customer_id` 필드를 기준으로 `customers` 컬렉션과 조인하고, 조인된 데이터를 `customer_info` 필드로 결과에 포함합니다.

또한, `$lookup`는 다음과 같은 추가 파라미터를 지원합니다:

- **`pipeline`**: 조인된 컬렉션에서 추가적인 어그리게이션 파이프라인 단계를 적용할 수 있습니다.
- **`let`**: 로컬 변수를 사용하여 `pipeline`을 구성할 때 도움이 됩니다.

예를 들어, 조인 후 필터링을 수행하는 `$lookup`:

```json
db.orders.aggregate([
  {
    $lookup: {
      from: "products",
      let: { order_id: "$_id" },
      pipeline: [
        { $match: { $expr: { $eq: ["$order_id", "$$order_id"] } } },
        { $project: { product_name: 1, quantity: 1 } }
      ],
      as: "product_info"
    }
  }
])
```

이 예시에서는 `products` 컬렉션에서 `order_id` 필드를 기준으로 추가적인 필터링을 통해 데이터를 가져옵니다.

이러한 다양한 기능을 통해 `$lookup`은 MongoDB에서 관계형 데이터베이스의 조인과 유사한 기능을 제공합니다.

MongoDB에서 내장된(document-embedded) 구조와 `$lookup`을 사용한 조인을 선택할 때, 다양한 요소를 고려해야 합니다. 이 결정은 데이터 모델링, 성능, 복잡성 및 유지보수 측면에서 중요한 영향을 미칠 수 있습니다.

## 내장된 Document를 사용하는 경우
내장된 구조는 데이터가 하나의 문서에 포함되는 것을 의미합니다. 이를 사용할 때 고려해야 할 점은 다음과 같습니다:

- **데이터 일관성**: 관련 데이터가 같은 문서에 포함되어 있기 때문에 데이터 일관성이 유지됩니다. 조인 없이도 모든 데이터를 가져올 수 있습니다.
- **빠른 읽기 성능**: 조인 없이 데이터를 직접 읽을 수 있어 빠른 읽기 성능을 제공합니다.
- **데이터 규모 제한**: MongoDB 문서는 최대 16MB 크기 제한이 있으므로, 데이터 규모가 큰 경우 문제를 일으킬 수 있습니다.
- **유연성 부족**: 데이터 구조가 단단히 결합되므로 유연성이 떨어집니다. 특정 필드만 업데이트하기 어렵거나 문서 구조 변경이 어렵습니다.

## `$lookup`을 사용하는 경우

`$lookup`은 데이터가 서로 다른 컬렉션에 저장된 경우 조인을 통해 관련 데이터를 가져올 때 사용됩니다. 이를 사용할 때 고려해야 할 점은 다음과 같습니다:

- **데이터 확장성**: 내장된 구조와 달리, 데이터 규모 제한이 없으므로 확장성이 높습니다.
- **유연한 데이터 구조**: 서로 다른 컬렉션에서 데이터를 가져올 수 있어 데이터 구조 변경에 유연합니다.
- **성능 저하 가능성**: 조인 연산이 추가되므로 복잡한 조인은 성능을 저하시킬 수 있습니다.
- **데이터 일관성**: 조인할 때 데이터 일관성이 떨어질 수 있습니다. 데이터가 변경되면 조인 결과가 예상치 못한 결과를 낼 수 있습니다.

## 결론

내장된 구조와 `$lookup` 중 어느 것을 선택할지는 데이터 모델링 요구사항과 사용 사례에 따라 다릅니다.

- **내장된 구조를 고려할 때**:
  - 관련 데이터가 강하게 연관되어 있을 때
  - 문서 크기가 16MB를 넘지 않을 때
  - 빠른 읽기 성능이 중요할 때
  
- **`$lookup`을 고려할 때**:
  - 서로 다른 컬렉션에 저장된 데이터를 조인할 때
  - 데이터 구조가 유연해야 할 때
  - 데이터 규모가 크거나 확장성이 필요할 때
